use futures_util::StreamExt;
use std::time::Duration;
use std::{path::PathBuf, process::Command};
use strsim::levenshtein;
use tokio::time::sleep;
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};
use tracing::debug;

#[tokio::test]
async fn test_transcription_accuracy() {
    println!("starting transcription accuracy test");

    // Setup test cases
    let test_cases = vec![
        (
            "test_data/accuracy1.wav",
            r#"yo louis, here's the tldr of that mind-blowing meeting:
        - bob's cat walked across his keyboard 3 times. productivity increased by 200%.
        - sarah's virtual background glitched, revealing she was actually on a beach. no one noticed.
        - you successfully pretended to be engaged while scrolling twitter. achievement unlocked!
        - 7 people said "you're on mute" in perfect synchronization. new world record.
        - meeting could've been an email. shocking.
        key takeaway: we're all living in a simulation, and the devs are laughing.
        peace out, llama3.2:3b-instruct-q4_K_M"#,
        ),
        (
            "test_data/accuracy2.wav",
            r#"bro - got some good stuff from screenpipe here's the lowdown on your day, you productivity ninja:
        - absolutely demolished that 2-hour coding sesh on the new feature. the keyboard is still smoking, bro!
        - crushed 3 client calls like a boss. they're probably writing love letters to you as we speak, make sure to close john tomorrow 8.00 am according to our notes, let the cash flow in!
        - spent 45 mins on slack. 90% memes, 10% actual work. perfectly balanced, as all things should be
        - watched a rust tutorial. way to flex those brain muscles, you nerd!
        overall, you're killing it! 80% of your time on high-value tasks. the other 20%? probably spent admiring your own reflection, you handsome devil.
        PS: seriously, quit tiktok. your FBI agent is getting bored watching you scroll endlessly.
        what's the plan for tomorrow? more coding? more memes? world domination?
        generated by your screenpipe ai assistant (who's definitely not planning to take over the world... yet)"#,
        ),
        (
            "test_data/accuracy3.wav",
            r#"again, screenpipe allows you to get meeting summaries, locally, without leaking data to OpenAI, with any apps, like WhatsApp, Meet, Zoom, etc. and it's open source at github.com/mediar-ai/screenpipe"#,
        ),
        (
            "test_data/accuracy4.wav",
            r#"Eventually but, I mean, I feel like but, I mean, first, I mean, you think your your vision smart will be interesting because, yeah, you install once. You pay us, you install once. That that yours. So, basically, all the time Microsoft explained, you know, MS Office, long time ago, you just buy the the the software that you can using there forever unless you wanna you wanna update upgrade is the better version. Right? So it's a little bit, you know"#,
        ),
        (
            "test_data/accuracy5.wav",
            r#"Thank you. Yeah. So I cannot they they took it, refresh because of my one set top top time. And, also, second thing is, your byte was stolen. By the time?"#,
        ),
        // Add more test cases as needed
    ];

    // Define a struct to manage the CLI and ffplay processes
    struct CliProcess {
        cli_process: std::process::Child,
        ffplay_processes: Vec<std::process::Child>,
    }

    impl Drop for CliProcess {
        fn drop(&mut self) {
            let _ = self.cli_process.kill();
            for ffplay_process in &mut self.ffplay_processes {
                let _ = ffplay_process.kill();
            }
        }
    }

    // Run the CLI
    let dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../target/release");
    println!("CLI path: {:?}", dir.join("screenpipe"));
    let mut cli_process = CliProcess {
        cli_process: Command::new(dir.join("screenpipe"))
            .arg("--port")
            .arg("3035")
            .arg("--data-dir")
            .arg("/tmp/sp-test")
            .spawn()
            .expect("Failed to start screenpipe CLI"),
        ffplay_processes: Vec::new(),
    };

    // Allow some time for the CLI to start
    sleep(Duration::from_secs(20)).await;

    // Connect to the WebSocket API
    let (ws_stream, _) = connect_async("ws://localhost:3035/ws/audio/transcriptions")
        .await
        .expect("Failed to connect to WebSocket");
    let (_, mut read) = ws_stream.split();

    for (audio_file, expected_transcription) in test_cases {
        // Use ffplay to play the audio file in the background
        let ffplay_command = Command::new("ffplay")
            .arg("-nodisp") // No display window
            .arg("-autoexit") // Exit when done
            .arg("-loglevel")
            .arg("quiet") // Suppress output
            .arg(audio_file)
            .spawn()
            .expect("Failed to start ffplay process");

        // Add the ffplay process to the list for cleanup
        cli_process.ffplay_processes.push(ffplay_command);

        // Wait for the transcription response
        let mut full_transcription = String::new();

        while let Some(message) = read.next().await {
            match message {
                Ok(Message::Text(response)) => {
                    println!("received response: {}", response);
                    full_transcription.push_str(&response);
                }
                Ok(_) => println!("received non-text message"),
                Err(e) => {
                    println!("error receiving message: {:?}", e);
                    break;
                }
            }
        }

        // Calculate accuracy
        let distance = levenshtein(expected_transcription, &full_transcription);
        let accuracy = 1.0 - (distance as f64 / expected_transcription.len() as f64);

        println!("expected: {}", expected_transcription);
        println!("actual: {}", full_transcription);
        println!("file: {}", audio_file);
        println!("accuracy: {:.2}%", accuracy * 100.0);
        // Wait for the ffplay process to complete
        if let Some(mut ffplay_process) = cli_process.ffplay_processes.pop() {
            let _ = ffplay_process
                .wait()
                .expect("Failed to wait on ffplay process");
        }
    }

    // Clean up
    cli_process
        .cli_process
        .kill()
        .expect("Failed to kill CLI process");
}
